# InnoDB 如何实现并发控制

 做并发控制无非两点
- 锁
- 数据多版本

## 锁
普通锁语义：
1. 操作数据前，先锁住，实施互斥，不允许其他并发操作目标数据。
2. 操作完成后，释放锁，让其他任务执行。

#### 存在的问题
普通锁语义太过粗暴，连读操作也会阻塞，任务执行本质是串行化的。

于是**共享锁和排它锁**出现了：
- 共享锁（Share Lock，也成为S锁），读取数据加S锁
- 排它锁（Exclusive Lock，也成为X锁），修改数据时加X锁

两者搭配：
- 共享锁之间不互斥，读读可以并行
- 排它锁与任何锁互斥，写读、写写不可并行

## 数据多版本
数据多版本是一种能够进一步提高并发的方法，它的核心原理是：
1. 写任务发生时，将数据克隆一份，以版本号区分
2. 写任务操作新克隆的数据，直至提交
3. 并发读任务可以继续读取旧版本的数据，不至于阻塞

## InnoDB如何实现数据多版本方案
InnoDB 通过 undo 段来实现数据多版本方案。undo 用来在事务中回滚数据，因此快照数据本身没有额外的开销。也因为没有事务对历史数据进行修改操作，所以快照数据是不需要上锁的。

InnoDB 内核会对行数据增加三个内部属性：
1. DB_TRX_ID，6字节，记录每一行最近一次修改它的事务ID；
2. DB_ROLL_PTR，7字节，记录指向回滚段undo日志的指针；
3. DB_ROW_ID，6字节，单调递增的行ID；

通过这三个内部属性，就可以定位到存储于 undo 中的历史版本数据，这种通过读取历史版本数据来避免阻塞写操作的方式也称为 MVCC（多版本并发控制）。这种**一致性不加锁读**也是 InnoDB 能做到高并发的核心原因之一。

## 仅存在于RC和RR级别
上面说到的基于 MVCC 机制的一致性不加锁读实际上并不是在4个事务隔离级别中都存在。对于 read uncommitted 级别它允许读请求读到未提交的事务，所以不需要快照介入；对于 serializable 级别它是完全串行化的，也不需要快照介入。

除此之外，在 read committed 和 read repeatable 级别下，对于快照的定义也是不同的。

### RC
在 read committed 级别下，非锁定一致性读总是读取被锁定的最新一份数据快照。

### RR
在 read repeatable 级别下，非锁定一致性读总是读取事务开始时的行数据版本。

### 举例

| 时间 | 会话A | 会话B |
| ------ | ------ | ------|
| 1 | begin; |  |
| 2 | select * from tb where id = 1; |  |
| 3 |  | begin; |
| 4 |  | update tb set name = 3 where id = 1; |
| 5 | select * from tb where id = 1; |  |
| 6 |  | commit;|
| 7 | select * from tb where id = 1; |  |
| 8 | commit; |  |

时间5的结果不管在RC还是RR级别都是id=1

时间7的结果在RC级别下是id=3，而在RR级别下是id=1